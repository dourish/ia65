
;;; IA65 is an interactive assembler for the 65C02 processor, with
;;; the goal of being self-hosted.
;;;
;;; The starting point is something that will assemble line-by-
;;; line, and then after that, something that can also read
;;; from an SD card as if it were terminal input.
;;;
;;; It is written for the Mite 6502 single-board computer.
;;; http://www.dourish.com/projects/mite.html
;;;
;;; Paul Dourish, October 2019
;;;



#include "../mitemon/decl.a65"

SCRATCH    = $0010  ; through to $001F
PRINTVEC   = $0042  ; and $0043. for printing routine.
INPUT      = $0200  ; block out this page for monitor command input
AMODE      = $02FF
LINELEN    = $002E
LINENO     = $002C  ; and 002D
ORG        = $002A  ; and 002B

  * = $0300

#include "../mitemon/init.a65"

init_acia
  lda #%00001011                ;No parity, no echo, no interrupt
  sta ACIA_COMMAND
  lda #%00011111                ;1 stop bit, 8 data bits, 19200 baud
  sta ACIA_CONTROL

  lda #<greeting
  sta PRINTVEC
  lda #>greeting
  sta PRINTVEC+1
  jsr printvecstr
  stz LINENO
  stz LINENO+1
  stz ORG
  stz ORG+1


  ;; main loop -- read a line of text and interpret it as
  ;; an instruction of assembly language.
  ;;
crnextline
  jsr crlf

nextline
  lda ORG+1
  jsr putax
  lda ORG
  jsr putax
  lda #$20
  jsr puta
  jsr puta

  jsr readline      ; read a line to INPUT
  lda #0            ; terminate with a NUL
  sta INPUT,y
  sty LINELEN       ; cache line length

  clc               ; increment line number by 1
  lda LINENO
  adc #1
  sta LINENO
.(
  bcc skip
  inc LINENO+1
skip
.)

  lda INPUT         ; instructions?
  cmp #"X
  bne processline
  jsr crlf          ; exit...
  jmp end

processline

  ;; find first non-space character
  ldy #0
.(
nextchar
  lda INPUT,y
  beq nextline
  cmp #$20          ; skip spaces
  beq space
  cmp #$09          ; skip tabs
  bne nonspace
space
  iny
  bra nextchar  
nonspace
.)

  ;; found non-space character. start to decode. possibilities
  ;; are a comment, a directive, a label, or an instruction.
  ;;
  cmp #';
  beq crnextline    ; skip comments to end of line

  cmp #'.
  beq directive

  ;; attempt to interpret it as an opcode first. look it up
  ;; in the table. uses SCRATCH as pointer into the table,
  ;; which will also be result if successful.
  lda #<opcodes
  sta SCRATCH
  lda #>opcodes
  sta SCRATCH+1

  clc               ; set up SCRATCH+2 as text pointer
  tya
  adc #<INPUT
  sta SCRATCH+2
  lda #>INPUT
  adc #0
  sta SCRATCH+3 

testopcode
  lda (SCRATCH)     ; zero indicates end-of-table
  beq endoftable

  ;; compare opcode strings. opcodes are only three characters
  ;; long, so we unroll this rather than implement it as a loop.
  ldy #0
  lda (SCRATCH),y   ; first character
  cmp (SCRATCH+2),y
  bne nextentry
  iny
  lda (SCRATCH),y   ; second character
  cmp (SCRATCH+2),y
  bne nextentry
  iny
  lda (SCRATCH),y   ; third character
  cmp (SCRATCH+2),y
  beq foundmatch

  ;; no entry found, so move on to the next table entry
nextentry
  clc
  lda SCRATCH
  adc #15           ; table entries are 15 bytes long
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)
  bra testopcode

endoftable
;; not an opcode, so perhaps a label?
  lda #$20
  jsr puta
  lda #"X
  jsr puta
  jsr puta
  jsr puta
  jsr crlf
  jmp nextline


directive
  ;; we detected a leading period, so determine if this is a
  ;; assembler directive. the table dirtable contains directives
  ;; and jump addresses for each.

  lda #<dirtable    ; set up pointer to table
  sta SCRATCH
  lda #>dirtable
  sta SCRATCH+1

  clc               ; set up pointer to text
  tya
  adc #<INPUT
  sta SCRATCH+2
  lda #>INPUT+1
  adc #0
  sta SCRATCH+3

.(
testdir
  lda (SCRATCH)
  bne enddirtable
  tay

nextchar
  lda (SCRATCH),y
  cmp (SCRATCH+2),y
  bne nextdir
  dey
  bne nextchar
  ;; successful match

nextdir
  clc
  lda (SCRATCH)
  adc #3
  adc SCRATCH
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)
  bra testdir
.)

enddirtable
  jmp direrror

orgdir
  ;; set code address to value specified
  ;; first, skip space
  ;; BUG BUG DO THIS

  ;; read the address
  jsr read16hex

  ;; set ORG
  lda SCRATCH+12
  sta ORG
  lda SCRATCH+13
  sta ORG+1
  jmp crnextline

bytedir
  ;; nothing here yet (implement .BYTE)

worddir
  ;; nothing here yet (implement .WORD)


;; syntax error
syntaxerror
;; overflow error
overflow
;; error if not found
direrror
;; directiveerror
error
  jmp end


;; we have found a match in the opcode table. now we need to
;; decode the operand text, which will also give us the addressing
;; mode.
;;
foundmatch
  ;; skip over opcode text
  clc
  lda SCRATCH+2
  adc #3
  sta SCRATCH+2
.(
  bcc skip
  inc SCRATCH+3
skip
.)

  ;; skip spaces to find operand
  ldy #0
.(
nextchar
  lda (SCRATCH+2),y
  beq nonspace
  cmp #$20
  beq space
  cmp #$09
  bne nonspace
space
  iny
  bra nextchar
nonspace
.)
  clc               ; update pointer to start of operand text
  tya
  adc SCRATCH+2
  sta SCRATCH+2
  lda SCRATCH+3
  adc #0
  sta SCRATCH+3

  ;; if we found nothing, it's implied or accumulator mode,
  ;; depending on the instruction.
.(
  lda (SCRATCH+2)
  bne next

  ldy #I_IMP        ; does implied mode work?
  lda (SCRATCH),y
  cmp #$ff
  bne done

  lda #I_ACC        ; try accumulator mode
  lda (SCRATCH),y
  cmp #$ff
  beq done

  jmp syntaxerror   ; neither matches, so error

done
  sty AMODE
  jmp output1       ; output a single byte instruction

next
.)

  ;; now test for relative addressing mode. instructions that take
  ;; relative addresses take ONLY relative addresses, so we do
  ;; this based on the instruction alone.
.(
  ldy #I_REL
  lda (SCRATCH),y
  cmp #$ff
  beq next

  lda SCRATCH+2
  sta SCRATCH+14
  lda SCRATCH+3
  sta SCRATCH+15

  lda (SCRATCH+2)
  bne proceed
  jmp syntaxerror
proceed
  jsr read16hex

  lda SCRATCH+13    ; there should be only an 8-bit value for
  beq continue      ; a relative address. check for overflow.
  jmp overflow
  
continue
  sty AMODE
  jmp output2       ; output two-byte instruction

next
.)

  ;; test for immediate mode by looking for the # symbol
.(
  lda (SCRATCH+2)
  cmp #"#
  bne next2

immediate
  clc
  lda SCRATCH+2     ; skip past the hash symbol
  adc #1
  sta SCRATCH+14
  lda SCRATCH+3
  adc #0
  sta SCRATCH+15
  jsr read16hex     ; and read the value

  lda SCRATCH+13    ; any data in the top byte implies an overflow
  beq continue
  jmp overflow

continue
  ldy #I_IMM
  sty AMODE
  jmp output2

next2
.)

  ;; check for parenthesis for all the indirect modes
  lda (SCRATCH+2),y
  cmp #"(
  bne nonparen
  jmp parenmodes

nonparen
  ;; we have now eliminated immediate, accumulator, implied, relative,
  ;; and indirect modes. so we are left with absolute and zero page,
  ;; including indexed.

  ;; read the numeric value of the operand. input to the read
  ;; routine is in SCRATCH+14/15, output in SCRATCH+12/13
  lda SCRATCH+2
  sta SCRATCH+14
  lda SCRATCH+3
  sta SCRATCH+15
  jsr read16hex

  ;; is there a trailing comma after the operand?
  lda (SCRATCH+14)
  cmp #$2c
  bne abszp

  ;; found a comma, so it's an indexed mode... which index register?
  ldy #1
  lda (SCRATCH+14),y
  cmp #"Y
  beq indexy        ; for Y index

  ;; indexed by X. determine ABSX or ZPX
  lda SCRATCH+13    ; check if MSB is zero
  bne absx          ; no, so definitely ABSX
  ldy #I_ZPX        ; yes, so try ZPX
  sty AMODE

  ;; check that instruction exists
  lda (SCRATCH),y
  cmp #$ff
  beq absx          ; default to absx if there is no zpx opcode

  jmp output2
absx
  ldy #I_ABSX
  sty AMODE
  jmp output3

indexy
  ;; indexed by Y. determine ABSY or ZPY
  lda SCRATCH+13    ; check if MSB is zero
  bne absy          ; no, so definitely ABSY
  ldy #I_ZPY        ; yes, so try ZPY
  sty AMODE

  ;; check that instruction exists
  lda (SCRATCH),y
  cmp #$ff
  beq absy          ; default to absy if there is no zpy opcode
  jmp output2

absy
  ldy #I_ABSY
  sty AMODE
  jmp output3

abszp
  ;; having eliminated other possibilities, the addressing mode
  ;; is either absolute or zero page depending on upper byte
  ;; and on whether the instruction has a zero page opcode

  lda SCRATCH+13
  bne absolute

  ;; does the instruction have a ZP opcode?
  ldy #I_ZP
  lda (SCRATCH),y
  cmp #$ff
  beq absolute

  sty AMODE
  jmp output2

absolute
  ldy #I_ABS
  sty AMODE
  jmp output3

parenmodes
  ;; (zp),y
  ;; (zp)
  ;; (zp,x)

  clc               ; move text pointer past parenthesis
  lda SCRATCH+14
  adc #1
  sta SCRATCH+14
.(
  bcc skip
  inc SCRATCH+15
skip
.)

  jsr read16hex     ; read the address

  ;; is the next character a comma?
  lda (SCRATCH+14)
  cmp #$2c
  beq inxind

  ;; BUG BUG BUG THIS IS NOT FINISHED!
  lda #'X
  jsr puta
  jsr puta
  jsr puta

  jmp crnextline

  ;; is the next character a close paren?

inxind
  ;; index indirect (ie (foo,x))
  ;; test to be sure
  ldy #1
  lda (SCRATCH+14),y
  cmp #'x
  beq okay
  cmp #'X
  beq okay
  lda SCRATCH+13
  beq okay
  jmp syntaxerror
okay
  ldy #I_INDX
  sty AMODE
  jmp output2


output3
  jsr padto25
  ldy AMODE         ; load addressing mode into Y
  lda (SCRATCH),y   ; load opcode from table
  jsr putax         ; print opcode
  lda #$20
  jsr puta          ; print a space
  lda SCRATCH+12    ; print lower byte
  jsr putax
  lda #$20
  jsr puta          ; print a space
  lda SCRATCH+13    ; print upper byte
  jsr putax

.(
  clc               ; increment code address pointer by 3
  lda ORG
  adc #3
  sta ORG
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

output2
  jsr padto25
  ldy AMODE
  lda (SCRATCH),y
  jsr putax         ; print opcode
  lda #$20
  jsr puta
  lda SCRATCH+12    ; print lower byte
  jsr putax

.(
  clc               ; increment code address pointer by 2
  lda ORG
  adc #2
  sta ORG
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

output1
  jsr padto25
  ldy AMODE
  lda (SCRATCH),y
  jsr putax         ; print opcode

.(
  clc               ; increment code address pointer by 1
  lda ORG
  adc #1
  sta ORG
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

end
  rts

padto25
.(
  pha
  lda LINELEN
  cmp #25
  bmi continue
  jsr crlf
  ldy #25
  bra spaces
continue
  lda #25
  sec
  sbc LINELEN
  tay
spaces
  lda #$20
space
  jsr puta
  dey
  bne space
  pla
.)
  rts



greeting:	 .byte "Interactive Assembler for Mite 6502", $0d, $0a, $00

#include "tables.a65"

#include "utils.a65"
