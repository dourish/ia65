
;;; IA65 is an interactive assembler for the 65C02 processor, with
;;; the goal of being self-hosted.
;;;
;;; The starting point is something that will assemble line-by-
;;; line, and then after that, something that can also read
;;; from an SD card as if it were terminal input.
;;;
;;; It is written for the Mite 6502 single-board computer.
;;; http://www.dourish.com/projects/mite.html
;;;
;;; Paul Dourish, October 2019
;;;



#include "../mitemon/decl.a65"

SCRATCH    = $0010  ; through to $001F
PRINTVEC   = $0042  ; and $0043. for printing routine.
INPUT      = $0200  ; block out this page for monitor command input
AMODE      = $02FF
LINELEN    = $002E

  * = $0300

#include "../mitemon/init.a65"

init_acia
  lda #%00001011                ;No parity, no echo, no interrupt
  sta ACIA_COMMAND
  lda #%00011111                ;1 stop bit, 8 data bits, 19200 baud
  sta ACIA_CONTROL

  lda #<greeting
  sta PRINTVEC
  lda #>greeting
  sta PRINTVEC+1
  jsr printvecstr


  ;; main loop -- read a line of text and interpret it as
  ;; an instruction of assembly language.
  ;;
crnextline
  jsr crlf

nextline
  jsr readline      ; read a line to INPUT
  lda #0            ; terminate with a NUL
  sta INPUT,y
  sty LINELEN       ; cache line length

  lda INPUT         ; instructions?
  cmp #"X
  bne processline
  jsr crlf          ; exit...
  jmp end

processline

  ;; find first non-space character
  ldy #0
.(
nextchar
  lda INPUT,y
  beq nextline
  cmp #$20
  beq space
  cmp #$09          ; tab
  bne nonspace
space
  iny
  bra nextchar  
nonspace
.)

  ;; found non-space character. start to decode. possibilities
  ;; are a comment, a directive, a label, or an instruction.
  ;;
  cmp #';
  beq crnextline    ; skip comments to end of line

  ;; for the moment, presume it's an opcode. search the opcode
  ;; table
  lda #<opcodes
  sta SCRATCH       ; pointer into the table
  lda #>opcodes
  sta SCRATCH+1
  clc
  tya
  adc #<INPUT
  sta SCRATCH+2
  lda #>INPUT
  adc #0
  sta SCRATCH+3 

testentry
  lda (SCRATCH)     ; zero indicates end-of-table
  beq endoftable

  ;; compare opcode strings. opcodes are only three characters
  ;; long, so we unroll this rather than implement it as a loop.
  ldy #0
  lda (SCRATCH),y   ; first character
  cmp (SCRATCH+2),y
  bne nextentry
  iny
  lda (SCRATCH),y   ; second character
  cmp (SCRATCH+2),y
  bne nextentry
  iny
  lda (SCRATCH),y   ; third character
  cmp (SCRATCH+2),y
  beq foundmatch

  ;; no entry found, so move on to the next table entry
nextentry
  clc
  lda SCRATCH
  adc #15           ; table entries are 15 bytes long
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)
  bra testentry

endoftable
;; not an opcode, so perhaps a label?
  lda #$20
  jsr puta
  lda #"X
  jsr puta
  jsr puta
  jsr puta
  jsr crlf
  jmp nextline

;; overflow error
overflow
;; error if not found
error
  jmp end


;; we have found a match in the opcode table. now we need to
;; decode the operand text, which will also give us the addressing
;; mode.
;;
foundmatch
  ;; skip over opcode text
  clc
  lda SCRATCH+2
  adc #3
  sta SCRATCH+2
.(
  bcc skip
  inc SCRATCH+3
skip
.)

  ;; skip spaces to find operand
  ldy #0
.(
nextchar
  lda (SCRATCH+2),y
  beq nonspace
  cmp #$20
  beq space
  cmp #$09
  bne nonspace
space
  iny
  bra nextchar
nonspace
.)
  clc               ; update pointer to start of operand text
  tya
  adc SCRATCH+2
  sta SCRATCH+2
  lda SCRATCH+3
  adc #0
  sta SCRATCH+3

  ;; if we found nothing, it's implied or accumulator mode,
  ;; depending on the instruction.
.(
  lda (SCRATCH+2)
  bne next

  ldy #I_IMP        ; does implied mode work?
  lda (SCRATCH),y
  cmp #$ff
  bne done

  lda #I_ACC        ; try accumulator mode
  lda (SCRATCH),y
  cmp #$ff
  beq done

  jmp error

done
  jsr padto25

  sty AMODE
  jsr padto25
  lda (SCRATCH),y
  jsr putax
  jmp crnextline

next
.)

  ;; now test for relative addressing mode. instructions that take
  ;; relative addresses take ONLY relative addresses, so we do
  ;; this based on the instruction alone.
.(
  ldy #I_REL
  lda (SCRATCH),y
  cmp #$ff
  beq next

  lda SCRATCH+2
  sta SCRATCH+14
  lda SCRATCH+3
  sta SCRATCH+15
  jsr read16hex

  lda SCRATCH+13    ; there should be only an 8-bit value for
  beq continue      ; a relative address. check for overflow.
  jmp overflow
  
continue
  jsr padto25

  sty AMODE
  lda (SCRATCH),y
  jsr putax
  lda #$20
  jsr puta
  lda SCRATCH+12
  jsr putax
  jmp crnextline

next
.)

  ;; test for immediate mode by looking for the # symbol
.(
  lda (SCRATCH+2)
  cmp #"#
  bne next

  clc
  lda SCRATCH+2
  adc #1
  sta SCRATCH+14
  lda SCRATCH+3
  adc #0
  sta SCRATCH+15
  jsr read16hex

  lda SCRATCH+13    ; any data in the top byte implies an overflow
  beq continue
  jmp overflow

continue
  ldy #I_IMM
  sty AMODE
  lda (SCRATCH),y

  jsr padto25
  jsr putax
  lda #$20
  jsr puta
  lda SCRATCH+12
  jsr putax
  jmp crnextline

next
.)

  lda (SCRATCH+2),y ; check for a parenthesis for all indirect modes
  cmp #"(
  beq parenmodes

  ;; we have now eliminated immediate, accumulator, implied, relative,
  ;; and indirect modes. so we are left with absolute and zero page,
  ;; including indexed.

  ;; read the numeric value of the operand. input to the read
  ;; routine is in SCRATCH+14/15, output in SCRATCH+12/13
  lda SCRATCH+2
  sta SCRATCH+14
  lda SCRATCH+3
  sta SCRATCH+15
  jsr read16hex

  ;; is there a trailing comma? BUG BUG this is crap
  ldy #4
  cmp #$2c
  bne abszp

  ;; it's an indexed mode...
  ;; BUG NOT DONE YET

  lda #$20
  jsr puta
  lda SCRATCH+13
  jsr putax
  lda SCRATCH+12
  jsr putax
  jsr crlf
  jmp nextline

abszp
  ;; it's either absolute or zero page depending on upper byte
  ;; and on whether the instruction has a zero page opcode

  lda SCRATCH+13
  bne absolute

  ;; does the instruction have a ZP opcode?
  ldy #I_ZP
  cmp #$ff
  beq absolute

  jsr padto25
  lda (SCRATCH),y
  jsr putax         ; print opcode
  lda #$20
  jsr puta
  lda SCRATCH+12    ; print lower byte
  jsr putax
  jmp crnextline  

absolute
  jsr padto25
  ldy #I_ABS
  lda (SCRATCH),y
  jsr putax         ; print opcode
  lda #$20
  jsr puta
  lda SCRATCH+12    ; print lower byte
  jsr putax
  lda #$20
  jsr puta
  lda SCRATCH+13    ; print upper byte
  jsr putax
  jmp crnextline

parenmodes
  lda #$28
  jsr puta

;; error
  lda #$FF
  sta AMODE


gotmode
  ldy AMODE
  lda #32
  jsr puta
  lda (SCRATCH),y
  jsr putax
  lda #32
  jsr puta

  jsr crlf
  jmp nextline

end
  rts

padto25
.(
  pha
  lda LINELEN
  cmp #25
  bpl contine
  jsr crlf
  ldy #25
  bra spaces
contine
  lda #25
  sec
  sbc LINELEN
  tay
spaces
  lda #$20
space
  jsr puta
  dey
  bne space
  pla
.)
  rts



greeting:	 .byte "Interactive Assembler for Mite 6502", $0d, $0a, $00

#include "tables.a65"

#include "utils.a65"
