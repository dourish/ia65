
;;; IA65 is an interactive assembler for the 65C02 processor, with
;;; the goal of being self-hosted.
;;;
;;; The starting point is something that will assemble line-by-
;;; line, and then after that, something that can also read
;;; from an SD card file as if it were terminal input.
;;;
;;; It is written for the Mite 6502 single-board computer.
;;; Details at http://www.dourish.com/projects/mite.html
;;;
;;; Paul Dourish, October 2019
;;;



#include "../mitemon/decl.a65"

SCRATCH    = $0010  ; through to $001F
PRINTVEC   = $0042  ; and $0043. for printing routine.
INPUT      = $0200  ; block out mos of page for terminal input

;;; zero page variables. I use most of the locations below 0080
;;; for other purposes. 0080 through 00FF are the FORTH stack,
;;; which grows downwards, so nibbling space from off the bottom
;;; of this space is the safest bet.
LABELS     = $0080  ; and 0081

AMODE      = $02E0
LINELEN    = $02E1
LINENO     = $02E2  ; and 02E3
ORG        = $02E4  ; and 02E5
OUT        = $02E6  ; and 02E7
IN         = $02E8  ; and 02E0

OUTBASE=$4000       ; file output area
INBASE=$4800        ; file input area

  * = $0300

#ifdef STANDALONE
#include "../mitemon/init.a65"

init_acia
  lda #%00001011    ; No parity, no echo, no interrupt
  sta ACIA_COMMAND
  lda #%00011111    ; 1 stop bit, 8 data bits, 19200 baud
  sta ACIA_CONTROL
#endif

  ;; issue startup message and initialize variables
  ;;
  lda #<greeting    ; print the greeting
  sta PRINTVEC
  lda #>greeting
  sta PRINTVEC+1
  jsr printvecstr

  stz LINENO        ; zero out line count
  stz LINENO+1
  stz ORG           ; zero out assembly address
  stz ORG+1
  stz LABELS        ; initialize labels table pointer
  lda #$70          ; MSB of end of the labels table
  sta LABELS+1
  lda #<OUTBASE     ; initialize OUT to OUTBASE
  sta OUT
  lda #>OUTBASE
  sta OUT+1
  lda #<INBASE      ; initialize IN to INBASE
  sta IN
  lda #>INBASE
  sta IN+1

  ;; main loop -- read a line of text and interpret it as
  ;; a label, a comment, a directive, or a line of assembly
  ;; language program
  ;;
crnextline
  jsr crlf

nextline
  lda ORG+1         ; print current address as a prompt
  jsr putax
  lda ORG
  jsr putax
  lda #$20
  jsr puta
  jsr puta

  jsr readline      ; read a line to INPUT
  lda #0            ; terminate with a NUL
  sta INPUT,y
  sty LINELEN       ; cache line length

  clc               ; increment line number by 1
  lda LINENO
  adc #1
  sta LINENO
.(
  bcc skip
  inc LINENO+1
skip
.)

  ;; find first non-space character
  ldy #0
.(
nextchar
  lda INPUT,y
  beq crnextline    ; blank line -- loop around
  cmp #$20          ; skip spaces
  beq space
  cmp #$09          ; skip tabs
  bne nonspace
space
  iny
  bra nextchar  
nonspace
.)

continueline
  ;; found non-space character. start to decode. possibilities
  ;; are a comment, a directive, a label, or an instruction.
  ;;
  cmp #";"	    ; skip comments to end of line
  beq crnextline

  cmp #"."          ; period signals an assembler directive
  bne labelorop
  jmp directive

labelorop
  ;; attempt to interpret it as an opcode first. look it up
  ;; in the table. uses SCRATCH as pointer into the table,
  ;; which will also be result if successful.
  lda #<opcodes
  sta SCRATCH
  lda #>opcodes
  sta SCRATCH+1

  clc               ; set up SCRATCH+2 as text pointer
  tya
  adc #<INPUT
  sta SCRATCH+2
  lda #>INPUT
  adc #0
  sta SCRATCH+3 

testopcode
  lda (SCRATCH)     ; zero indicates end-of-table
  beq endoftable

  ;; compare opcode strings. opcodes are only three characters
  ;; long, so we unroll this rather than implement it as a loop.
  ldy #0
  lda (SCRATCH+2),y ; first character
  and #%11011111    ; adjust case for case-independent matching
  cmp (SCRATCH),y
  bne nextentry
  iny
  lda (SCRATCH+2),y ; second character
  and #%11011111    ; adjust case for case-independent matching
  cmp (SCRATCH),y
  bne nextentry
  iny
  lda (SCRATCH+2),y ; third character
  and #%11011111    ; adjust case for case-independent matching
  cmp (SCRATCH),y
  bne nextentry
  jmp foundmatch

  ;; no entry found, so move on to the next table entry
nextentry
  clc
  lda SCRATCH
  adc #15           ; table entries are 15 bytes long
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)
  bra testopcode

endoftable
  ;; didn't find a matching opcode, so presume that this
  ;; is a label and add it to the label table
  jsr addlabel

.(
  ;; is there more text to process on this line? first skip
  ;; space and then see if there is text left.
  ldy #0
skiptext
  lda (SCRATCH+2),y
  beq nomoretext
  cmp #$20
  beq spaces
  cmp #$09
  beq spaces
  iny
  bra skiptext
spaces
  iny
  lda (SCRATCH+2),y
  beq nomoretext
  cmp #$20
  beq spaces
  cmp #$09
  beq spaces
.)

  ;; if we get here, there is more text to process. update
  ;; text pointer.
  clc
  tya
  adc SCRATCH+2
  sta SCRATCH+2
.(
  bcc skip
  inc SCRATCH+3
skip
.)
  lda (SCRATCH+2)   ; reload current character
  jmp continueline

nomoretext
  ;; no more text to process so end this line
  jmp crnextline


;; we have found a match in the opcode table. now we need to
;; decode the operand text, which will also give us the addressing
;; mode.
;;
foundmatch
  ;; skip over opcode text
  clc
  lda SCRATCH+2
  adc #3
  sta SCRATCH+2
.(
  bcc skip
  inc SCRATCH+3
skip
.)

  ;; skip spaces to find operand
  ldy #0
.(
nextchar
  lda (SCRATCH+2),y
  beq nonspace
  cmp #$20
  beq space
  cmp #$09
  bne nonspace
space
  iny
  bra nextchar
nonspace
.)
  clc               ; update pointer to start of operand text
  tya
  adc SCRATCH+2
  sta SCRATCH+2
  lda SCRATCH+3
  adc #0
  sta SCRATCH+3

  ;; if we found no operand, then it's implied or accumulator mode,
  ;; depending on the instruction. test for each.
.(
  lda (SCRATCH+2)
  bne next

  ldy #I_IMP        ; does implied mode work?
  lda (SCRATCH),y
  cmp #$ff          ; $ff signals no valid opcode for this mode
  bne done

  ldy #I_ACC        ; try accumulator mode
  lda (SCRATCH),y
  cmp #$ff
  bne done

  jmp syntaxerror   ; neither matches, so issue an error

done
  ;; on success, output the opcode
  sty AMODE
  jmp output1       ; output a single byte instruction

next
.)

  ;; now test for relative addressing mode. instructions that take
  ;; relative addresses take ONLY relative addresses, so we do
  ;; this based on the instruction alone.
.(
  ldy #I_REL
  lda (SCRATCH),y
  cmp #$ff
  beq next

  ;; set up text pointer to read the operand
  lda SCRATCH+2
  sta SCRATCH+14
  lda SCRATCH+3
  sta SCRATCH+15

  lda (SCRATCH+2)
  bne proceed
  jmp syntaxerror   ; syntax error if there is no operand provided

proceed
  jsr readvalue     ; read value (either number or a label)

temp
  ;; for relative mode, we need a relative address.
  ;; subtract ORG from the destination address, and then
  ;; adjust by 2 for the instruction we are assembling.
  sec
  lda SCRATCH+12
  sbc ORG
  sta SCRATCH+12
  lda SCRATCH+13
  sbc ORG+1
  sta SCRATCH+13

  sec
  lda SCRATCH+12
  sbc #2
  sta SCRATCH+12
  lda SCRATCH+13
  sbc #0
  sta SCRATCH+13

;; BUG BUG BUG NOT CHECKING FOR OUT OF RANGE
;  lda SCRATCH+13    ; there should be only an 8-bit value for
;  beq continue      ; a relative address. check for overflow.
;  jmp overflow
  
continue
  ldy #I_REL
  sty AMODE
  jmp output2       ; output two-byte instruction

next
.)

  ;; test for immediate mode by looking for the # symbol
.(
  lda (SCRATCH+2)
  cmp #"#
  bne next2

immediate
  clc
  lda SCRATCH+2     ; skip past the hash symbol
  adc #1
  sta SCRATCH+14
  lda SCRATCH+3
  adc #0
  sta SCRATCH+15
  jsr readvalue

  lda SCRATCH+13    ; any data in the top byte implies an overflow
  beq continue
  jmp overflow

continue
  ldy #I_IMM
  sty AMODE
  jmp output2

next2
.)

  ;; check for parenthesis for all the indirect modes
  lda (SCRATCH+2)
  cmp #"(
  bne nonparen
  jmp parenmodes

nonparen
  ;; we have now eliminated immediate, accumulator, implied, relative,
  ;; and indirect modes. so we are left with absolute and zero page,
  ;; including indexed.

  ;; read the numeric value of the operand. input to the read
  ;; routine is in SCRATCH+14/15, output in SCRATCH+12/13
  lda SCRATCH+2
  sta SCRATCH+14
  lda SCRATCH+3
  sta SCRATCH+15
  jsr readvalue

  ;; is there a trailing comma after the operand?
  lda (SCRATCH+14)
  cmp #$2c
  bne abszp

  ;; found a comma, so it's an indexed mode... which index register?
  ldy #1
  lda (SCRATCH+14),y
  cmp #"Y
  beq indexy        ; for Y index

  ;; indexed by X. determine ABSX or ZPX
  lda SCRATCH+13    ; check if MSB is zero
  bne absx          ; no, so definitely ABSX
  ldy #I_ZPX        ; yes, so try ZPX
  sty AMODE

  ;; check that instruction exists
  lda (SCRATCH),y
  cmp #$ff
  beq absx          ; default to absx if there is no zpx opcode

  jmp output2
absx
  ldy #I_ABSX
  sty AMODE
  jmp output3

indexy
  ;; indexed by Y. determine ABSY or ZPY
  lda SCRATCH+13    ; check if MSB is zero
  bne absy          ; no, so definitely ABSY
  ldy #I_ZPY        ; yes, so try ZPY
  sty AMODE

  ;; check that instruction exists
  lda (SCRATCH),y
  cmp #$ff
  beq absy          ; default to absy if there is no zpy opcode
  jmp output2

absy
  ldy #I_ABSY
  sty AMODE
  jmp output3

abszp
  ;; having eliminated other possibilities, the addressing mode
  ;; is either absolute or zero page depending on upper byte
  ;; and on whether the instruction has a zero page opcode

  lda SCRATCH+13
  bne absolute

  ;; does the instruction have a ZP opcode?
  ldy #I_ZP
  lda (SCRATCH),y
  cmp #$ff
  beq absolute

  sty AMODE
  jmp output2

absolute
  ldy #I_ABS
  sty AMODE
  jmp output3

parenmodes
  ;; (zp),y
  ;; (zp)
  ;; (zp,x)

  clc               ; move text pointer past opening parenthesis
  lda SCRATCH+2
  adc #1
  sta SCRATCH+14
  lda SCRATCH+3
  adc #0
  sta SCRATCH+15

;;  jsr read16hex     ; read the address
  jsr readvalue

  ;; is the next character a comma?
  lda (SCRATCH+14)
  cmp #$2c
  beq inxind        ; if so, it's indexed indirect

  ;; is the next character a close paren?
  cmp #$29
  beq zpindy
  jmp syntaxerror

zpindy
  ;; this is either (zp) or (zp),y
  ldy #1
  lda (SCRATCH+14),y
  cmp #$2c           ; comma?
  beq indy

  ;; this is where (ZP) support should go but I don't
  ;; have it yet BUG BUG BUG
  jmp syntaxerror

indy
  ldy #I_INDY
  sty AMODE
  jmp output2


inxind
  ;; index indirect (ie (foo,x))
  ;; test to be sure
  ldy #1
  lda (SCRATCH+14),y
  and #%11011111
  cmp #'X
  beq okay
  lda SCRATCH+13
  beq okay
  jmp syntaxerror
okay
  ldy #I_INDX
  sty AMODE
  jmp output2


;;;
;;; output routines.
;;;

output3
  jsr padto25
  ldy AMODE         ; load addressing mode into Y
  lda (SCRATCH),y   ; load opcode from table
  jsr putax         ; print opcode
  lda #$20
  jsr puta          ; print a space
  lda SCRATCH+12    ; print lower byte
  jsr putax
  lda #$20
  jsr puta          ; print a space
  lda SCRATCH+13    ; print upper byte
  jsr putax

.(
  clc               ; increment code address pointer by 3
  lda ORG
  adc #3
  sta ORG
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

output2
  jsr padto25
  ldy AMODE
  lda (SCRATCH),y
  jsr putax         ; print opcode
  lda #$20
  jsr puta
  lda SCRATCH+12    ; print lower byte
  jsr putax

.(
  clc               ; increment code address pointer by 2
  lda ORG
  adc #2
  sta ORG
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

output1
  jsr padto25
  ldy AMODE
  lda (SCRATCH),y
  jsr putax         ; print opcode

.(
  clc               ; increment code address pointer by 1
  lda ORG
  adc #1
  sta ORG
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

end
  rts


;;;
;;; handle assembler directives
;;;

directive
  ;; we detected a leading period, so determine if this is a
  ;; assembler directive. the table dirtable contains directives
  ;; and jump addresses for each.

  lda #<dirtable    ; set up pointer to table
  sta SCRATCH
  lda #>dirtable
  sta SCRATCH+1

  clc               ; set up pointer to text
  tya
  adc #<INPUT
  sta SCRATCH+2
  lda #>INPUT+1
  adc #0
  sta SCRATCH+3

.(
testdir
  lda (SCRATCH)
  beq enddirtable
  tay

nextchar
  lda (SCRATCH+2),y
  and #%11011111    ; adjust case for case-independent matching
  cmp (SCRATCH),y
  bne nextdir
  dey
  bne nextchar

  ;; successful match
  ;; set up text pointer for read16hex, skipping space

  clc
  lda (SCRATCH)     ; load the count for the matching directive
  inc               ; add one to allow for the leading period
  adc SCRATCH+2     ; add to the text pointer
  sta SCRATCH+14    ; deposit where read16hex will look
  lda SCRATCH+3
  adc #0
  sta SCRATCH+15

.(
  ldy #0
skipspace
  lda (SCRATCH+14),y
  beq nonspace      ; terminate at end-of-line
  cmp #$20          ; skip spaces
  beq space
  cmp #$09          ; skip tabs
  bne nonspace
space
  iny
  bra skipspace
nonspace
  clc
  tya
  adc SCRATCH+14
  sta SCRATCH+14
  bcc skip
  inc SCRATCH+15
skip
.)
  clc               ; set SCRATCH to the jump address
  lda (SCRATCH)     ; which is COUNT+1 bytes past the start
  inc
  adc SCRATCH
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)
  ldy #1            ; grab address, pointed to by SCRATCH
  lda (SCRATCH)     ; and store it in SCRATCH again
  pha               ; cache LSB
  lda (SCRATCH),y   ; fetch MSB
  sta SCRATCH+1     ; store MSB
  pla               ; retrieve LSB
  sta SCRATCH       ; store LSB
  jmp (SCRATCH)     ; jump to that address

nextdir
  clc
  lda (SCRATCH)
  adc #3
  adc SCRATCH
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)
  bra testdir
.)

enddirtable
  jmp direrror

;;; implement .ORG, setting code address to value specified
orgdir
  ;; read the address
  jsr read16hex

  ;; set ORG
  lda SCRATCH+12
  sta ORG
  lda SCRATCH+13
  sta ORG+1
  jmp crnextline

;;; implement .BYTE, writing a single byte into the stream
bytedir
  ;; read the address
  jsr read16hex
  lda SCRATCH+13
  bne msb
  jsr padto25
  lda SCRATCH+12
  jsr putax
  clc
  lda ORG
  adc #1
  sta ORG
.(
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

msb
  jmp overflow


;;; implemented .WORD, writing a two-byte word into the stream.
worddir
  ;; read the address
  jsr read16hex
  jsr padto25
  lda SCRATCH+12
  jsr putax
  lda #$20
  jsr puta
  lda SCRATCH+13
  jsr putax
  clc
  lda ORG
  adc #2
  sta ORG
.(
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

;; implement .EQU, setting value of last label
equdir
  ;; read the address
  jsr read16hex

  ldy #14
  lda SCRATCH+12
  sta (LABELS),y
  iny
  lda SCRATCH+13
  sta (LABELS),y
;  jsr padto25
;  lda SCRATCH+12
;  jsr putax
;  lda #$20
;  jsr puta
;  lda SCRATCH+13
;  jsr putax
  jmp crnextline


;;;
;;; the labels table grows downward from $7000
;;; all entries are 16 bytes long -- 14 padded with zeros for the
;;; label and two for the value
;;;

addlabel
  sec               ; set SCRATCH to be address of new
  lda LABELS        ; entry in the labels table
  sbc #16
  sta SCRATCH
  lda LABELS+1
  sbc #0
  sta SCRATCH+1

  ldy #0
copychar
  lda (SCRATCH+2),y
  beq copyspaces
  cmp #$20
  beq copyspaces
  cmp #":"          ; treat colon as end-of-label
  beq copyspaces
  sta (SCRATCH),y
  iny
  cpy #14
  bne copychar
  lda #32
copyspaces
  cpy #14
  beq endcopy
  lda #0
  sta (SCRATCH),y
  iny
  bra copyspaces
endcopy

  ;; by default, set value to current address
  lda ORG
  sta (SCRATCH),y
  iny
  lda ORG+1
  sta (SCRATCH),y

  ;; update LABELS
  lda SCRATCH
  sta LABELS
  lda SCRATCH+1
  sta LABELS+1

  rts

;; readvalue reads a value, which may be a label (in which case, it
;; substitutes the value of that label), or it may be an 8- or
;; 16-bit word. the input pointer is SCRATCH+14 and the value is
;; returned in SCRATCH+12.
readvalue

  ;; start with most recent label
  lda LABELS
  sta SCRATCH+4
  lda LABELS+1
  sta SCRATCH+5

testlabel
  lda SCRATCH+5
  cmp #$70          ; if we move onto this page, table is ended
  beq nomorelabels
  ldy #0
labelchar
  lda (SCRATCH+4),y
  beq foundlabel    ; end of label
  cmp (SCRATCH+14),y
  bne nextlabel
  iny
  cpy #14           ; stop if we reach the end
  beq foundlabel
  bra labelchar

nextlabel
  clc               ; move on to next entry in label table
  lda SCRATCH+4
  adc #16
  sta SCRATCH+4
.(
  bcc skip
  inc SCRATCH+5
skip
.)
  bra testlabel

foundlabel
  ldy #14
  lda (SCRATCH+4),y
  sta SCRATCH+12
  iny
  lda (SCRATCH+4),y
  sta SCRATCH+13
  rts

nomorelabels
  jmp read16hex     ; rts from there

;;; errors

syntaxerror
  jsr crlf
  lda #<syntaxerrstr
  sta PRINTVEC
  lda #>syntaxerrstr
  sta PRINTVEC+1
  bra genericerror

overflow
  jsr crlf
  lda #<overflowerrstr
  sta PRINTVEC
  lda #>overflowerrstr
  sta PRINTVEC+1
  bra genericerror

direrror
  jsr crlf
  lda #<direrrstr
  sta PRINTVEC
  lda #>direrrstr
  sta PRINTVEC+1
  bra genericerror

genericerror
  jsr printvecstr   ; print the error message
  lda #<onlinestr   ; print the "on line" message
  sta PRINTVEC
  lda #>onlinestr
  sta PRINTVEC+1
  jsr printvecstr
  lda LINENO+1      ; print the line number
  jsr putax
  lda LINENO
  jsr putax
  jsr crlf
error
  jmp end




padto25
.(
  pha
  lda LINELEN
  cmp #25
  bmi continue
  jsr crlf
  ldy #25
  bra spaces
continue
  lda #25
  sec
  sbc LINELEN
  tay
spaces
  lda #$20
space
  jsr puta
  dey
  bne space
  pla
.)
  rts



greeting:	 .byte "Interactive Assembler for Mite 6502", $0d, $0a, $00
direrrstr:       .byte "Unrecognized directive", $00
syntaxerrstr:    .byte "Syntax error", $00
overflowerrstr:  .byte "Overflow error", $00
onlinestr:       .byte " on line $", $00

#include "tables.a65"

#include "utils.a65"
