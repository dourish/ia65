
;;; IA65 is an interactive assembler for the 65C02 processor, with
;;; the goal of being self-hosted.
;;;
;;; The starting point is something that will assemble line-by-
;;; line, and then after that, something that can also read
;;; from an SD card file as if it were terminal input.
;;;
;;; It is written for the Mite 6502 single-board computer.
;;; Details at http://www.dourish.com/projects/mite.html
;;;
;;; Paul Dourish, October 2019
;;;



#include "../mitemon/decl.a65"

SCRATCH    = $0010  ; through to $001F
PRINTVEC   = $0042  ; and $0043. for printing routine.
INPUT      = $0200  ; block out mos of page for terminal input

;;; zero page variables. I use most of the locations below 0080
;;; for other purposes. 0080 through 00FF are the FORTH stack,
;;; which grows downwards, so nibbling space from off the bottom
;;; of this space is the safest bet.
LABELS     = $0080  ; and 0081
OUT        = $0082  ; and 0083
IN         = $0084  ; and 0085

AMODE      = $02E0
LINELEN    = $02E1
LINENO     = $02E2  ; and 02E3
ORG        = $02E4  ; and 02E5

OUTBASE=$4000       ; file output area
INBASE=$4800        ; file input area

  * = $0300

#ifdef STANDALONE
#include "../mitemon/init.a65"

init_acia
  lda #%00001011    ; No parity, no echo, no interrupt
  sta ACIA_COMMAND
  lda #%00011111    ; 1 stop bit, 8 data bits, 19200 baud
  sta ACIA_CONTROL
#endif

;;;
;;;
;;; SECTION 1 -- STARTUP AND MAIN LOOP
;;;
;;;

  ;; issue startup message and initialize variables
  ;;
  lda #<greeting    ; print the greeting
  sta PRINTVEC
  lda #>greeting
  sta PRINTVEC+1
  jsr printvecstr

  stz LINENO        ; zero out line count
  stz LINENO+1
  stz ORG           ; zero out assembly address
  stz ORG+1
  stz LABELS        ; initialize labels table pointer
  lda #$70          ; MSB of end of the labels table
  sta LABELS+1
  lda #<OUTBASE     ; initialize OUT to OUTBASE
  sta OUT
  lda #>OUTBASE
  sta OUT+1
  lda #<INBASE      ; initialize IN to INBASE
  sta IN
  lda #>INBASE
  sta IN+1

  ;; main loop -- read a line of text and interpret it as
  ;; a label, a comment, a directive, or a line of assembly
  ;; language code.
  ;;
crnextline
  jsr crlf

nextline
  lda ORG+1         ; print current address (ORG) as a prompt
  jsr putax
  lda ORG
  jsr putax
  lda #$20          ; then a couple of spaces
  jsr puta
  jsr puta

  jsr readline      ; read a line to INPUT
  lda #0            ; terminate with a NULL
  sta INPUT,y
  sty LINELEN       ; cache line length

  clc               ; bump line count by 1 for error reporting
  lda LINENO
  adc #1
  sta LINENO
.(
  bcc skip
  inc LINENO+1
skip
.)

  ;; find first non-space character on line
  ldy #0
.(
nextchar
  lda INPUT,y
  beq crnextline    ; blank line -- loop around
  cmp #$20          ; skip spaces
  beq space
  cmp #$09          ; skip tabs
  bne nonspace
space
  iny
  bra nextchar  
nonspace
.)

continueline
  ;; found non-space character. start to decode. possibilities
  ;; are a comment, a directive, a label, or an instruction.
  ;;
  cmp #";"	    ; skip comments to end of line
  beq crnextline

  cmp #"."          ; period signals an assembler directive
  bne labelorop
  jmp directive

labelorop
  ;; attempt to interpret it as an opcode first. look it up
  ;; in the table. uses SCRATCH as pointer into the table,
  ;; which will also be result if successful.
  lda #<opcodes
  sta SCRATCH
  lda #>opcodes
  sta SCRATCH+1

  clc               ; set up SCRATCH+2 as text pointer
  tya
  adc #<INPUT
  sta SCRATCH+2
  lda #>INPUT
  adc #0
  sta SCRATCH+3 

testopcode
  ;; test if current opcode table pointer is a match
  ;;
  lda (SCRATCH)     ; zero indicates end-of-table
  beq endoftable

  ;; compare opcode strings. opcodes are only three characters
  ;; long, so we unroll this rather than implement it as a loop.
  ldy #0
  lda (SCRATCH+2),y ; first character
  and #%11011111    ; adjust case for case-independent matching
  cmp (SCRATCH),y
  bne nextentry
  iny
  lda (SCRATCH+2),y ; second character
  and #%11011111    ; adjust case for case-independent matching
  cmp (SCRATCH),y
  bne nextentry
  iny
  lda (SCRATCH+2),y ; third character
  and #%11011111    ; adjust case for case-independent matching
  cmp (SCRATCH),y
  bne nextentry
  jmp foundmatch

  ;; no entry found, so move on to the next table entry
nextentry
  clc
  lda SCRATCH
  adc #16           ; table entries are 16 bytes long
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)
  bra testopcode

endoftable
  ;; didn't find a matching opcode, so presume that this
  ;; is a label and add it to the label table
  jsr addlabel

.(
  ;; is there more text to process on this line? first skip
  ;; space and then see if there is text left.
  ldy #0
skiptext
  lda (SCRATCH+2),y
  beq nomoretext
  cmp #$20
  beq spaces
  cmp #$09
  beq spaces
  iny
  bra skiptext
spaces
  iny
  lda (SCRATCH+2),y
  beq nomoretext
  cmp #$20
  beq spaces
  cmp #$09
  beq spaces
.)

  ;; if we get here, there is more text to process. update
  ;; text pointer.
  clc
  tya
  adc SCRATCH+2
  sta SCRATCH+2
.(
  bcc skip
  inc SCRATCH+3
skip
.)
  lda (SCRATCH+2)   ; reload current character
  jmp continueline

nomoretext
  ;; no more text to process so end this line
  jmp crnextline


;;;
;;;
;;; SECTION 2 -- INSTRUCTION DECODING
;;;
;;;


;; we have found a match in the opcode table. now we need to
;; decode the operand text, which will also give us the addressing
;; mode.
;;
foundmatch
  ;; skip over opcode text. opcodes are always 3 characters long,
  ;; so just add 3.
  clc
  lda SCRATCH+2
  adc #3
  sta SCRATCH+2
.(
  bcc skip
  inc SCRATCH+3
skip
.)

  ;; now skip over spaces to find operand
  ldy #0
.(
nextchar
  lda (SCRATCH+2),y
  beq nonspace
  cmp #$20
  beq space
  cmp #$09
  bne nonspace
space
  iny
  bra nextchar
nonspace
.)
  clc               ; update pointer to start of operand text
  tya
  adc SCRATCH+2
  sta SCRATCH+2
  lda SCRATCH+3
  adc #0
  sta SCRATCH+3

.(
  lda (SCRATCH+2)
  bne next          ; non-zero, so there is an operand present

  ;; if we found no operand, then the addressing mode is either
  ;; implied or accumulator, depending on the instruction. test for each.
  ;;
  ldy #I_IMP        ; does implied mode work?
  lda (SCRATCH),y
  cmp #$ff          ; $ff signals no valid opcode for this mode
  bne done

  ldy #I_ACC        ; try accumulator mode
  lda (SCRATCH),y
  cmp #$ff
  bne done

  jmp syntaxerror   ; neither matches, so issue an error

done
  ;; on success, output the opcode
  sty AMODE
  jmp output1       ; output a single byte instruction

next
.)

  ;; now test for relative addressing mode. instructions that take
  ;; relative addresses take ONLY relative addresses, so we do
  ;; this based on the instruction alone.
.(
  ldy #I_REL
  lda (SCRATCH),y
  cmp #$ff          ; $FF indicates an invalid mode for opcode
  beq next

  ;; set up text pointer to read the operand
  lda SCRATCH+2
  sta SCRATCH+14
  lda SCRATCH+3
  sta SCRATCH+15

  lda (SCRATCH+2)
  bne proceed
  jmp syntaxerror   ; syntax error if there is no operand provided

proceed
  jsr readvalue     ; read value (either number or a label)

temp
  ;; for relative mode, we need a relative address.
  ;; subtract ORG from the destination address, and then
  ;; adjust by 2 for the instruction we are assembling.
  sec
  lda SCRATCH+12
  sbc ORG
  sta SCRATCH+12
  lda SCRATCH+13
  sbc ORG+1
  sta SCRATCH+13

  sec
  lda SCRATCH+12
  sbc #2
  sta SCRATCH+12
  lda SCRATCH+13
  sbc #0
  sta SCRATCH+13

;; BUG BUG BUG NOT CHECKING FOR OUT OF RANGE
;  lda SCRATCH+13    ; there should be only an 8-bit value for
;  beq continue      ; a relative address. check for overflow.
;  jmp overflow
  
continue
  ldy #I_REL
  sty AMODE
  jmp output2       ; output two-byte instruction

next
.)

  ;; test for immediate mode by looking for the # symbol
.(
  lda (SCRATCH+2)
  cmp #"#
  bne next2         ; if not immediate, skip to next test

immediate
  clc
  lda SCRATCH+2     ; skip past the hash symbol
  adc #1
  sta SCRATCH+14
  lda SCRATCH+3
  adc #0
  sta SCRATCH+15
  jsr readvalue

  lda SCRATCH+13    ; any data in the top byte implies an overflow
  beq continue
  jmp overflow

continue
  ldy #I_IMM
  sty AMODE
  jmp output2

next2
.)

  ;; check for parenthesis for all the indirect modes
  lda (SCRATCH+2)
  cmp #"(
  bne nonparen
  jmp parenmodes

nonparen
  ;; we have now eliminated immediate, accumulator, implied, relative,
  ;; and indirect modes. so we are left with absolute and zero page,
  ;; including indexed.

  ;; read the numeric value of the operand. input to the read
  ;; routine is in SCRATCH+14/15, output in SCRATCH+12/13
  lda SCRATCH+2
  sta SCRATCH+14
  lda SCRATCH+3
  sta SCRATCH+15
  jsr readvalue

  ;; is there a trailing comma after the operand?
  lda (SCRATCH+14)
  cmp #$2c
  bne abszp

  ;; found a comma, so it's an indexed mode... which index register?
  ldy #1
  lda (SCRATCH+14),y
  cmp #"Y
  beq indexy        ; for Y index

  ;; indexed by X. determine ABSX or ZPX
  lda SCRATCH+13    ; check if MSB is zero
  bne absx          ; no, so definitely ABSX
  ldy #I_ZPX        ; yes, so try ZPX
  sty AMODE

  ;; check that instruction exists
  lda (SCRATCH),y
  cmp #$ff
  beq absx          ; default to absx if there is no zpx opcode
  jmp output2

absx
  ldy #I_ABSX
  sty AMODE
  jmp output3

indexy
  ;; indexed by Y. determine ABSY or ZPY
  lda SCRATCH+13    ; check if MSB is zero
  bne absy          ; no, so definitely ABSY
  ldy #I_ZPY        ; yes, so try ZPY
  sty AMODE

  ;; check that instruction exists
  lda (SCRATCH),y
  cmp #$ff
  beq absy          ; default to absy if there is no zpy opcode
  jmp output2

absy
  ldy #I_ABSY
  sty AMODE
  jmp output3

abszp
  ;; having eliminated other possibilities, the addressing mode
  ;; is either absolute or zero page depending on upper byte
  ;; and on whether the instruction has a zero page opcode

  lda SCRATCH+13
  bne absolute

  ;; does the instruction have a ZP opcode?
  ldy #I_ZP
  lda (SCRATCH),y
  cmp #$ff
  beq absolute

  sty AMODE
  jmp output2

absolute
  ldy #I_ABS
  sty AMODE
  jmp output3

parenmodes
  ;; (zp),y
  ;; (zp)
  ;; (zp,x)

  clc               ; move text pointer past opening parenthesis
  lda SCRATCH+2
  adc #1
  sta SCRATCH+14
  lda SCRATCH+3
  adc #0
  sta SCRATCH+15

;;  jsr read16hex     ; read the address
  jsr readvalue

  ;; is the next character a comma?
  lda (SCRATCH+14)
  cmp #$2c
  beq inxind        ; if so, it's indexed indirect

  ;; is the next character a close paren?
  cmp #$29
  beq zpindy
  jmp syntaxerror

zpindy
  ;; this is either (zp) or (zp),y
  ldy #1
  lda (SCRATCH+14),y
  cmp #$2c           ; comma?
  beq indy           ; yes, so it's (zp),y

  ;; no comma, so it's (ZP) 
  ldy #I_IZP
  sty AMODE
  ;; make sure that there's a valid opcode for thhis
  lda (SCRATCH),y
  cmp #$ff
  beq zpinvalid
  jmp output2
zpinvalid
  jmp syntaxerror

indy
  ldy #I_INDY
  sty AMODE
  jmp output2


inxind
  ;; index indirect (ie (foo,x))
  ;; test to be sure
  ldy #1
  lda (SCRATCH+14),y
  and #%11011111
  cmp #'X
  beq okay
  lda SCRATCH+13
  beq okay
  jmp syntaxerror
okay
  ldy #I_INDX
  sty AMODE
  jmp output2


;;;
;;; output routines. there are three routines, one for a
;;; three-byte instruction, one for a two-byte and one for
;;; a one-byte. Each of them does the same sequence of steps:
;;;  - make sure that there is space in the output area
;;;      for the instruction I'm about to write
;;;  - print the opcode and store it in the output area
;;;  - do the same for the operand bytes, if any
;;;  - increment OUT and ORG appropriately
;;;

;;; do the output for a three-byte instruction
output3
  jsr checkspace    ; ensure space in output area
  jsr padto25       ; move cursor
  ldy AMODE         ; load addressing mode into Y
  lda (SCRATCH),y   ; load opcode from table
  pha               ; temporarily record opcode
  jsr putax         ; print opcode
  ldy #0
  pla               ; pull opcode
  sta (OUT),y       ; store first byte in output area
  lda #$20
  jsr puta          ; print a space
  lda SCRATCH+12    ; load lower byte
  iny
  sta (OUT),y       ; store second byte in output area
  jsr putax
  lda #$20
  jsr puta          ; print a space
  lda SCRATCH+13    ; load upper byte
  iny
  sta (OUT),y       ; store third byte in output area
  jsr putax         ; print it


.(
  clc               ; increment code address pointer by 3
  lda ORG
  adc #3
  sta ORG
  bcc skip
  inc ORG+1
skip
.)
.(
  clc               ; increment output pointer by 3
  lda OUT
  adc #3
  sta OUT
  bcc skip
  inc OUT+1
skip
.)
  jmp crnextline


;; as above, but for a two-byte instruction
output2
  jsr checkspace
  jsr padto25
  ldy AMODE
  lda (SCRATCH),y

  ldy #0
  sta (OUT),y       ; store opcode
  jsr putax         ; print opcode
  lda #$20
  jsr puta
  lda SCRATCH+12    ; load lower byte/operand
  iny
  sta (OUT),y       ; store operand
  jsr putax         ; print operand

.(
  clc               ; increment code address pointer by 2
  lda ORG
  adc #2
  sta ORG
  bcc skip
  inc ORG+1
skip
.)
.(
  clc               ; increment output pointer by 2
  lda OUT
  adc #2
  sta OUT
  bcc skip
  inc OUT+1
skip
.)
  jmp crnextline

;; and again, only this time for a single-byte instruction
output1
  jsr checkspace
  jsr padto25
  ldy AMODE
  lda (SCRATCH),y
  sta (OUT)
  jsr putax         ; print opcode

.(
  clc               ; increment code address pointer by 1
  lda ORG
  adc #1
  sta ORG
  bcc skip
  inc ORG+1
skip
.)
.(
  clc               ; increment output pointer by 1
  lda OUT
  adc #1
  sta OUT
  bcc skip
  inc OUT+1
skip
.)
  jmp crnextline

end
  rts


;; check that there is enough space for the code we're going
;; to assemble (that is, at least three bytes). if not,
;; flush data to file and reset output pointer
checkspace
  lda OUT+1
  cmp #>INBASE-1        ; are we on the last available page?
  beq checklower
spaceokay
  rts               ; no, so there is space. return.
checklower
  lda #$FC          ; last valid pointer
  cmp OUT           ; check the lower byte
  bpl spaceokay

  ;; flush data BUG BUG BUG TO DO

  ;; reset output pointer
  lda #<OUTBASE
  sta OUT
  lda #>OUTBASE
  sta OUT+1
  rts


;;;
;;;
;;; SECTION 3 -- ASSEMBLER DIRECTIVES
;;;
;;;

directive
  ;; we detected a leading period, so determine if this is a
  ;; assembler directive. the table dirtable contains directives
  ;; and jump addresses for each.

  lda #<dirtable    ; set up pointer to table
  sta SCRATCH
  lda #>dirtable
  sta SCRATCH+1

  clc               ; set up pointer to text
  tya
  adc #<INPUT
  sta SCRATCH+2
  lda #>INPUT+1
  adc #0
  sta SCRATCH+3

.(
testdir
  lda (SCRATCH)
  beq enddirtable
  tay

nextchar
  lda (SCRATCH+2),y
  and #%11011111    ; adjust case for case-independent matching
  cmp (SCRATCH),y
  bne nextdir
  dey
  bne nextchar

  ;; successful match
  ;; set up text pointer for read16hex, skipping space

  clc
  lda (SCRATCH)     ; load the count for the matching directive
  inc               ; add one to allow for the leading period
  adc SCRATCH+2     ; add to the text pointer
  sta SCRATCH+14    ; deposit where read16hex will look
  lda SCRATCH+3
  adc #0
  sta SCRATCH+15

.(
  ldy #0
skipspace
  lda (SCRATCH+14),y
  beq nonspace      ; terminate at end-of-line
  cmp #$20          ; skip spaces
  beq space
  cmp #$09          ; skip tabs
  bne nonspace
space
  iny
  bra skipspace
nonspace
  clc
  tya
  adc SCRATCH+14
  sta SCRATCH+14
  bcc skip
  inc SCRATCH+15
skip
.)
  clc               ; set SCRATCH to the jump address
  lda (SCRATCH)     ; which is COUNT+1 bytes past the start
  inc
  adc SCRATCH
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)
  ldy #1            ; grab address, pointed to by SCRATCH
  lda (SCRATCH)     ; and store it in SCRATCH again
  pha               ; cache LSB
  lda (SCRATCH),y   ; fetch MSB
  sta SCRATCH+1     ; store MSB
  pla               ; retrieve LSB
  sta SCRATCH       ; store LSB
  jmp (SCRATCH)     ; jump to that address

nextdir
  clc
  lda (SCRATCH)
  adc #3
  adc SCRATCH
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)
  bra testdir
.)

enddirtable
  jmp direrror

;;; implement .ORG, setting code address to value specified
orgdir
  ;; read the address
  jsr read16hex

  ;; set ORG
  lda SCRATCH+12
  sta ORG
  lda SCRATCH+13
  sta ORG+1
  jmp crnextline

;;; implement .BYTE, writing a single byte into the stream
bytedir
  ;; read the address
  jsr read16hex
  lda SCRATCH+13
  bne msb
  jsr padto25
  lda SCRATCH+12
  jsr putax
  clc
  lda ORG
  adc #1
  sta ORG
.(
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

msb
  jmp overflow


;;; implemented .WORD, writing a two-byte word into the stream.
worddir
  ;; read the address
  jsr read16hex
  jsr padto25
  lda SCRATCH+12
  jsr putax
  lda #$20
  jsr puta
  lda SCRATCH+13
  jsr putax
  clc
  lda ORG
  adc #2
  sta ORG
.(
  bcc skip
  inc ORG+1
skip
.)
  jmp crnextline

;;; implement .EQU, setting value of last label
equdir
  ;; read the address
  jsr read16hex

  ldy #14
  lda SCRATCH+12
  sta (LABELS),y
  iny
  lda SCRATCH+13
  sta (LABELS),y
  jmp crnextline


;;; implement .DUMP. read the parameter either as a range (1000-10ff) or
;;; as a pair that indicate start and extend (e.g. 1000 ff).
dumpdir

  ;; get range parameters
  jsr getrange
  jsr crlf

  ;; dump data, one row of 16 bytes at a time
dumpnext16

  ldy #0

  ;; print one line

  ;; print the address
  lda SCRATCH+11
  jsr putax
  lda SCRATCH+10
  jsr putax

  ;; print separator
  lda #$3a         ; colon
  jsr puta
  lda #$20         ; space
  jsr puta

  ;; print first eight bytes
printbyte
  lda (SCRATCH+10),y
  jsr putax
  lda #$20
  jsr puta
  cpy #$07          ; if at the eighth, print extra separator
  bne nextbyte
  jsr puta
nextbyte            ; inc and move on to next byte
  iny
  cpy #$10          ; stop when we get to 16
  bne printbyte
  
  ;; print separator
  lda #$20
  jsr puta
  jsr puta
  lda #$7C          ; vertical bar
  jsr puta          ; faster to have that as a little character string!

  ;; print ascii values for 16 bytes
  ldy #0
nextascii
  cpy #$10
  beq endascii
  lda (SCRATCH+10),y
  ;; it's printable if it's over 32 and under 127
  cmp #32
  bmi unprintable
  cmp #127
  bmi printascii
unprintable
  lda #$2e          ; dot
printascii
  jsr puta
  iny
  bra nextascii
endascii
  lda #$7C          ; vertical bar
  jsr puta          ; faster to have that as a little character string!
  jsr crlf

  ;; now bump the address and check if we should go around again
  ;;
  clc

  ;; add 16 to the base
  clc
  lda SCRATCH+10
  adc #$10
  sta SCRATCH+10
.(
  bcc skip
  inc SCRATCH+11
skip
.)

  ;; compare to limit address
  sec
  lda SCRATCH+12
  sbc SCRATCH+10
  lda SCRATCH+13
  sbc SCRATCH+11
  bvc there
  eor #$80
there
  bpl here
  bra donedump
here
  jmp dumpnext16

donedump
  jmp nextline


;;; read parameters to directives to get a range of addresses. read
;;; either start-end or start offset.
;;; BUG BUG BUG should this accept labels?
getrange
  ;; read the address
  jsr read16hex

  ;; cache the address we just read
  lda SCRATCH+12
  sta SCRATCH+10
  lda SCRATCH+13
  sta SCRATCH+11

  ;; check for range, which is signalled by a hyphen
  lda (SCRATCH+14)
  cmp #"-
  bne readcount

  clc
  lda SCRATCH+14
  adc #1
  sta SCRATCH+14
.(
bcc skip
  inc SCRATCH+15
skip
.)
  ;; read next value as limit
  jsr read16hex
  bra gotrange

readcount
  ;; read next value as count. first, skip leading space
  ldy #0
skipspace
  lda (SCRATCH+14),y
  beq endrd
  cmp #$20
  beq gotspace
  cmp #$09
  beq gotspace
  bra notspace
gotspace
  iny
  bra skipspace
notspace
  clc
  tya
  adc SCRATCH+14
  sta SCRATCH+14
.(
  bcc skip
  inc SCRATCH+15
skip
.)
  ;; read a count
  jsr read16hex

  ;; calculate end of range and leave in S+12/13
  clc
  lda SCRATCH+10
  adc SCRATCH+12
  sta SCRATCH+12
  lda SCRATCH+11
  adc SCRATCH+13
  sta SCRATCH+13
  bra gotrange

endrd
  ;; read ended early. set end marker to same value as start.
  lda SCRATCH+10
  sta SCRATCH+12
  lda SCRATCH+11
  sta SCRATCH+13

gotrange
  rts


;;; implements .TEST -- used for various debugging purposes
testdir
  jsr read16hex
  lda #$20
  jsr puta
  lda SCRATCH+12
  jsr propcode
  jmp crnextline


;;;
;;;
;;; SECTION 4 -- DISASSEMBLER
;;;
;;;

disdir

  ;; get range parameters
  jsr getrange
  jsr crlf

  ;; now we actually do the work
  ;; stash base address at BASE (upper area of scratch memory)

BASE=SCRATCH+$0A
LIMIT=SCRATCH+12

  jmp begindis

;;; I'm following details and logic from
;;; http://www.llx.com/~nparker/a2/opcodes.html
;;;
;;; Most instructions are of the form aaabbbcc, where cc signals
;;; a block of instructons that operate in a similar way, with aaa
;;; indicating the instructoon and bbb indicating the addressing mode.
;;; Each of those blocks is handled by two tables, one of which
;;; indicates the opcode strings and one of which handles the
;;; addressing modes (by storing entry points into the processing
;;; routines).
;;;

begindis
  phx               ; preserve X (it's a stack pointer elsewhere)
  ldy #0            ; y will track bytes as we go

start
nextinst
  ;; start the line by printing the address and a couple of spaces
  ;;
  lda BASE+1
  jsr putax
  lda BASE
  jsr putax
  lda #$20
  jsr puta
  jsr puta
  jsr puta

  ;; before we handle the regular cases, check the table
  ;; of special cases which are harder to detect via regular
  ;; patterns
  ldx #0
nextspecial
  lda specialcasetable,x     ; load item from table
  cmp #$FF          ; check if it's the end of the table
  beq endspecial    ; if so, exit
  cmp (BASE),y      ; compare table item to instruction
  beq foundspecial  ; match?
  inx               ; move on to next table -- three bytes
  inx
  inx
  bra nextspecial   ; loop
foundspecial
  inx               ; when we find a match, jump to address in table
  jmp (specialcasetable,x)
endspecial          ; got to the end of the table without a match
  lda (BASE),y      ; re-load instruction
  
  ;; it's not a special case, so now start to move through the
  ;; different instruction formats. Each has a table with details.
  ;;
  and #%00011111    ; checking if it's a branch
  cmp #%00010000
  beq jbranch       ; jump to code for branches

  ;; block of single byte instructions where the lower nybble is 8
  ;;
testlow8
  lda (BASE),y      ; get the instruction again (last test was destructive)
  and #%00001111
  cmp #$08          ; single-byte instructions with 8 in lower nybble
  bne testxa
  jmp single8

  ;; block of single byte instructions at 8A, 9A, etc
testxa
  lda (BASE),y      ; get the instruction again (last test was destructive)
  and #%10001111
  cmp #$8A          ; 8A, 9A, etc
  bne testcc00
  jmp singlexa

  ;; otherwise, process according to the regular scheme of aaabbbcc
  ;;
testcc00
  lda (BASE),y      ; get the instruction again (last test was destructive)
  and #%00000011    ; look at the "cc" bits -- what sort of opcode?
  bne testcc10
  jmp branch00      ; go to branch for cc=00
testcc10
  cmp #%00000010
  bne testcc01
  jmp branch10     ; go to branch for cc=10
testcc01
  cmp #%00000001
  bne jothers       ; go to branch for remaining opcodes
  jmp branch01

jbranch
  jmp branch
jothers
  jmp others

;;; interpret according to the pattern for cc=01
;;;
branch01
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax
  ; so now cc01optable,x is the pointer to the right opcode
  lda cc01optable,x
  jsr propcode
  
  ;; handle each addressing mode
  ;; the addressing mode is going to determine how many
  ;; bytes we need to consume overall
  ;; so we do something similar... grab the bits, shift them down
  ;; and use that to look up a table which will tell us where
  ;; to jump to to interpret it correctly.
  
  lda (BASE),y      ; get the instruction again
  and #%00011100    ; extract the bbb bits -- addressing mode
  lsr               ; shift just once
  ;; acc now holds the offset of the right entry in the table
  ;; now add in the base address of the table, and store it in SCRATCH
  clc
  adc #<cc01adtable
  sta SCRATCH       ; less significant byte
  lda #>cc01adtable
  adc #0
  sta SCRATCH+1     ; most significant byte
  ;; one more level of indirection -- fetch the address listed there
  phy
  ldy #0
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  ply
  jmp (SCRATCH+2)   ; jump to address specified in table

;;;
;;; Routines to handle the output for different addressing modes.
;;; Each addressing mode has its own entry point; entries in the
;;; addressing tables for each instruction block point here directly.
;;; On entry and exit, Y indicates the last byte processed.
;;;

dacc
  ;; accumulator
  lda #'A
  jsr puta
  jmp endline

dabsx                ; absolute, X -- consumes two more bytes
  lda #'$
  jsr puta
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny               ; leave Y pointing to last byte consumed
  lda #',
  jsr puta
  lda #'X
  jsr puta
  jmp endline

dizpx                ; (zero page,X), consumes one more byte
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #',
  jsr puta
  lda #'X
  jsr puta
  lda #')
  jsr puta
  jmp endline

dzp                  ; zero page, consumes one more byte
  iny
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

dizp                 ; indirect zero page, only on 65C02, consumes 1 byte
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #')
  jsr puta
  jmp endline

dimm                 ; immediate mode, consumes one byte
  iny
  lda #'#
  jsr puta
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

dimmb                ; like immediate, but for branches (so ditch the "#")
  iny
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

dabs
  ;; absolute -- consumes two more bytes
  lda #'$
  jsr puta
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny               ; reset Y so that we move on correctly
  jmp endline

dizpy
  ;; (zero page),Y -- consumes one more byte
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #')
  jsr puta
  lda #',
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

dind
  ;; (addr) -- consumes two more bytes
  iny
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  dey
  lda (BASE),y
  jsr putax
  lda #')
  jsr puta
  iny
  jmp endline

dindx                ; only the JMP on 65C02?
  iny
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  dey
  lda (BASE),y
  jsr putax
  lda #',
  jsr puta
  lda #'X
  jsr puta
  lda #')
  jsr puta
  iny
  jmp endline

dzpx
  ;; zero page,X -- consumes one more byte
  iny
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #',
  jsr puta
  lda #'X
  jsr puta
  jmp endline

dzpy
  ;; zero page,Y -- consumes one more byte
  iny
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #',
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

dabsy
  ;; absolute,Y -- consumes two more bytes
  lda #'$
  jsr puta
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny               ; leave Y pointing to last byte consumed
  lda #',
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

err
  ;; can't interpret the opcode
  lda #'?
  jsr puta
  jsr puta
  jsr puta
  jmp endline

;;; the next major block of addresses is those where the two
;;; bottom bits are 10. Processing is very similar to those
;;; where cc=01, above.
;;; almost all this code is just reproduced from above.
;;; TODO-- restructure to share more of the mechanics.
;;;
branch10

  ;; first, take care of the unusual case of the 65C02 instructions
  ;; which use a different logic

  ;; look up and process opcode
  ;;
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax

  ;; before we proceed, decide which table to look up. the 65C02 codes
  ;; in the range bbb=100 use a differnt logic
  lda (BASE),y
  and #%00011100
  cmp #%00010000
  beq specialb10

  ; so now cc10optable,x is the pointer to the opcode
  lda cc10optable,x
  jmp b10opcode

specialb10
  lda cc01optable,x ; not an error... we're using the cc01 table for 65c02

b10opcode
  jsr propcode

;; handle each addressing mode
  ;;
  lda (BASE),y      ; get the instruction again
  cmp #$96          ; check fos special cases
  beq specialstx    ; STX in ZP,X mode becomes ZP,Y
  cmp #$b6
  beq specialldx1   ; LDX in ZP,X mode becomes ZP,Y
  cmp #$be
  beq specialldx2   ; LDX in ZP,X mode becomes ZP,Y

  ;; otherwise, proceed as usual
  and #%00011100    ; extract the bbb bits -- addressing mode
  lsr               ; shift just once
  ;; acc now holds the offset of the right entry in the table
  ;; now add in the base address of the table, and store it in SCRATCH
  clc
  adc #<cc10adtable
  sta SCRATCH       ; less significant byte
  lda #>cc10adtable
  adc #0
  sta SCRATCH+1     ; most significant byte
  ;; one more level of indirection -- fetch the address listed there
  phy
  ldy #0
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  ply
  jmp (SCRATCH+2)   ; jump to address specified in table

specialstx
specialldx1
  jmp dzpy
specialldx2
  jmp dabsy

;;; This code for the block of instructions with cc=00. Note again
;;; that this is simply repeated from above and should be fixed.
;;; TODO-- refactor this code to eliminate duplication
;;;
branch00
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax
  ; so now cc00optable,x is the pointer to the right opcode
  lda cc00optable,x
  jsr propcode

  ;; handle each addressing mode
  ;;
  lda (BASE),y      ; get the instruction again
  cmp #$89          ; special case for BIT #
  beq specialbit
  cmp #$6C          ; indirect JMP is a special case, handle separately
  beq specialindjmp 
  cmp #$7C          ; similarly for indirect JMP,X
  beq specialindxjmp  
  and #%00011100    ; extract the bbb bits -- addressing mode
  lsr               ; shift just once
  ;; acc now holds the offset of the right entry in the table
  ;; now add in the base address of the table, and store it in SCRATCH
  clc
  adc #<cc00adtable
  sta SCRATCH       ; less significant byte
  lda #>cc00adtable
  adc #0
  sta SCRATCH+1     ; most significant byte
  ;; one more level of indirection -- fetch the address listed there
  phy
  ldy #0
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  ply
  jmp (SCRATCH+2)   ; jump to address specified in table

specialbit
  ;; treat this specially -- 65C02 opcode slightly out of place
  jmp dimm

specialindjmp
  ;; treat JMP (address) specially
  jmp dind

specialindxjmp
  ;; treat JMP (address,X) specially
  jmp dindx


;;; branch instructions -- actually, these don't follow pattern so do FIRST
;;; branches have the form xxy10000
;;; xxy*2 should index into branchtable
branch
  lda (BASE),y
  and #%11100000
  lsr
  lsr
  lsr
  lsr
  tax

  ;; now index into table
  ; so now branchoptable,x is the pointer to the right opcode
  lda branchoptable,x
  jsr propcode

  ;; we use a variant form of immediate mode to print the operand
  ;; for branch instructions
  jmp dimmb

;;; these are the single-byte instructions with 8 in their lower nybble
;;; again, code borrowed from above (branch) -- TODO -- refactor.
single8
  lda (BASE),y
  and #%11110000
  lsr
  lsr
  lsr
  tax

  ;; now index into table
  ;; so now single08table,x is the pointer to the right opcode
  lda single08table,x
  jsr propcode
  jmp endline

;;; these are the single-byte instructions at 8A, 9A, etc.
;;; again, code borrowed from above (branch) -- TODO -- refactor.
singlexa
  lda (BASE),y
  and #%01110000
  lsr
  lsr
  lsr
  tax

  ;; now index into table
  ;; so now singlexatable,x is the pointer to the right opcode
  lda singlexatable,x
  jsr propcode
  jmp endline

;;; this is where we end up if we haven't figured anything else out
;;;
others
  lda #'?
  jsr puta
  jsr puta
  jsr puta
  jmp endline

;; disassembler special cases go here
;;
dobrk
  lda #O_BRK
  jsr propcode
  jmp endline

dojsr
  lda #O_JSR
  jsr propcode
  jmp dabs

dorti
  lda #O_RTI
  jsr propcode
  jmp endline

dorts
  lda #O_RTS
  jsr propcode
  jmp endline

dobra
  lda #O_BRA
  jsr propcode
  jmp dimmb

dotrbzp
  lda #O_TRB
  jsr propcode
  jmp dzp

dotrbabs
  lda #O_TRB
  jsr propcode
  jmp dabs

dostzzp
  lda #O_STZ
  jsr propcode
  jmp dzp

dostzabs
  lda #O_STZ
  jsr propcode
  jmp dabs

dostzzpx
  lda #O_STZ
  jsr propcode
  jmp dzpx

dostzabsx
  lda #O_STZ
  jsr propcode
  jmp dabsx

doplx
  lda #O_PLX
  jsr propcode
  jmp endline

dophx
  lda #O_PHX
  jsr propcode
  jmp endline

doply
  lda #O_PLY
  jsr propcode
  jmp endline

dophy
  lda #O_PHY
  jsr propcode
  jmp endline

doinca
  lda #O_INC
  jsr propcode
  lda #'A
  jsr puta
  jmp endline

dodeca
  lda #O_DEC
  jsr propcode
  lda #'A
  jsr puta
  jmp endline

endline
  jsr crlf

  ;; TEMP TEMP TEMP JUST STOP
  jmp nextline

  ;; at this point, Y points to the last processed byte. Increment
  ;; to move on, and add it to base.
  iny
  clc
  tya               ; move Y to ACC and add to BASE address
  adc BASE
  sta BASE          ; low byte
  lda BASE+1
  adc #0
  sta BASE+1        ; high byte
  ldy #0            ; reset Y

  ;; compare to limit address
  sec
  lda SCRATCH+12
  sbc SCRATCH+10
  lda SCRATCH+13
  sbc SCRATCH+11
;  bvc there
;  eor #$80
;there
;  bpl here
;  bra donedis
;here
;  jmp nextdis ;????

donedis
  jmp nextline

  ;; test if we should terminate... goes here...
;  dec COUNT
  beq finishdis

  jmp nextinst

finishdis
  plx               ; restore the stack pointer
exitdis
;  inx               ; pop one item off stack (one param)
;  inx
;  inx               ; pop second item off stack (other param)
;  inx
  jmp nextline
  


;;;
;;;
;;; SECTION 5 -- LABEL HANDLING
;;;
;;; The labels table grows downward from $7000. All entries are
;;; 16 bytes long -- 14 padded with zeros for the label and two
;;; for the value
;;;

addlabel
  sec               ; set SCRATCH to be address of new
  lda LABELS        ; entry in the labels table
  sbc #16
  sta SCRATCH
  lda LABELS+1
  sbc #0
  sta SCRATCH+1

  ldy #0
copychar
  lda (SCRATCH+2),y ; load label character
  beq copyspaces    ; check for NULL
  cmp #$20          ; check for space
  beq copyspaces
  cmp #":"          ; treat colon as end-of-label
  beq copyspaces
  sta (SCRATCH),y   ; store label character
  iny
  cpy #14           ; max characters?
  bne copychar
  lda #32
copyspaces
  cpy #14
  beq endcopy
  lda #0
  sta (SCRATCH),y   ; pad with NULLs
  iny
  bra copyspaces
endcopy
  ;; by the time we get here, Y is always set to 14, so it
  ;; points to the address field in the label's entry in table.
  ;; by default, set value to current address
  lda ORG
  sta (SCRATCH),y
  iny
  lda ORG+1
  sta (SCRATCH),y

  ;; update LABELS
  lda SCRATCH
  sta LABELS
  lda SCRATCH+1
  sta LABELS+1

  rts

;; readvalue reads a value, which may be a label (in which case, it
;; substitutes the value of that label), or it may be an 8- or
;; 16-bit word. the input pointer is SCRATCH+14 and the value is
;; returned in SCRATCH+12.
readvalue

  ;; start with most recent label
  lda LABELS
  sta SCRATCH+4
  lda LABELS+1
  sta SCRATCH+5

testlabel
  lda SCRATCH+5
  cmp #$70          ; if we move onto this page, table is ended
  beq nomorelabels
  ldy #0
labelchar
  lda (SCRATCH+4),y
  beq foundlabel    ; end of label
  cmp (SCRATCH+14),y
  bne nextlabel
  iny
  cpy #14           ; stop if we reach the end
  beq foundlabel
  bra labelchar

nextlabel
  clc               ; move on to next entry in label table
  lda SCRATCH+4
  adc #16
  sta SCRATCH+4
.(
  bcc skip
  inc SCRATCH+5
skip
.)
  bra testlabel

foundlabel
  ldy #14
  lda (SCRATCH+4),y
  sta SCRATCH+12
  iny
  lda (SCRATCH+4),y
  sta SCRATCH+13
  rts

nomorelabels
  jmp read16hex     ; rts from there


;;;
;;;
;;; SECTION 6 -- ERROR HANDLING
;;;
;;;

syntaxerror
  jsr crlf
  lda #<syntaxerrstr
  sta PRINTVEC
  lda #>syntaxerrstr
  sta PRINTVEC+1
  bra genericerror

overflow
  jsr crlf
  lda #<overflowerrstr
  sta PRINTVEC
  lda #>overflowerrstr
  sta PRINTVEC+1
  bra genericerror

direrror
  jsr crlf
  lda #<direrrstr
  sta PRINTVEC
  lda #>direrrstr
  sta PRINTVEC+1
  bra genericerror

genericerror
  jsr printvecstr   ; print the error message
  lda #<onlinestr   ; print the "on line" message
  sta PRINTVEC
  lda #>onlinestr
  sta PRINTVEC+1
  jsr printvecstr
  lda LINENO+1      ; print the line number
  jsr putax
  lda LINENO
  jsr putax
  jsr crlf
error
  jmp end



;;;
;;;
;;; SECTION 7 -- UTILITY FUNCTIONS
;;;
;;;


padto25
.(
  pha
  lda LINELEN
  cmp #25
  bmi continue
  jsr crlf
  ldy #25
  bra spaces
continue
  lda #25
  sec
  sbc LINELEN
  tay
spaces
  lda #$20
space
  jsr puta
  dey
  bne space
  pla
.)
  rts

;; print the opcode indicated by the A register, plus trailing space.
;;; nukes SCRATCH/+1.
propcode
  ;; turn opcode into a two-byte value
  sta SCRATCH
  stz SCRATCH+1

  ;; multiply it by 16 (length of a row in the opcode table).
  asl SCRATCH
  rol SCRATCH+1
  asl SCRATCH
  rol SCRATCH+1
  asl SCRATCH
  rol SCRATCH+1
  asl SCRATCH
  rol SCRATCH+1

  ;; add that to the opcode table base
  clc
  lda SCRATCH
  adc #<opcodes
  sta SCRATCH
  lda SCRATCH+1
  adc #>opcodes
  sta SCRATCH+1

  phy
  ldy #0
  lda (SCRATCH),y
  jsr puta
  iny
  lda (SCRATCH),y
  jsr puta
  iny
  lda (SCRATCH),y
  jsr puta
  lda #$20
  jsr puta
  ply

  rts


greeting:	 .byte "Interactive Assembler for Mite 6502", $0d, $0a, $00
direrrstr:       .byte "Unrecognized directive", $00
syntaxerrstr:    .byte "Syntax error", $00
overflowerrstr:  .byte "Overflow error", $00
onlinestr:       .byte " on line $", $00
diserrorstring:  .byte ".DIS hexaddress [count: 10]",$00

#include "tables.a65"

#include "utils.a65"
